import socketimport osimport timeimport threadingimport randomfrom chat_tcp_client_obj import ChatClientGuifrom chat_tcp_server import ChatServerGui# check_list:# check port availability#exitFlag = 0class MyThread(threading.Thread):    def __init__(self, thread_id, name, counter):        threading.Thread.__init__(self)        self.threadID = thread_id        self.name = name        self.counter = counter    def run(self):        print("Starting " + self.name)        print_time(self.name, self.counter, 5)        print("Exiting " + self.name)def print_time(threadName, delay, counter):    while counter:        if exitFlag:            threadName.exit()        time.sleep(delay)        print("%s: %s" % (threadName, time.ctime(time.time())))        counter -= 1class ChatServer:    def __init__(self, port):        self.serverSocket = None        self.serverSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        self.serverSocket.settimeout(60)        self.serverSocket.bind(('', port))        self.serverSocket.listen(1)        print('The server is ready to receive')        value = self.start_chat()        return value    def start_chat(self):        connectionSocket, addr = self.serverSocket.accept()        while True:            sentence = connectionSocket.recv(1024).decode()            print('received_message' + sentence)            send_data = input("input_data_to_send : ")            connectionSocket.send(send_data.encode())            if sentence == '<finish chat>':                connectionSocket.close()                break        return 0class ChatClient:    def __init__(self, serverPort, serverIP):        self.clientSocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        self.clientSocket.settimeout(60)        self.clientSocket.connect((serverIP, serverPort))        print('chat has been started : \n')        self.start_chat()    def start_chat(self):        while True:            sentence = input("for finishing the chat, please type <finish chat>: \n")            self.clientSocket.send(sentence.encode())            data, address = self.clientSocket.recv(1024)            print('From Server: ', data.decode())            if data.decode == "<finish chat>":                self.clientSocket.close()                break        return 0class UdpBroadCaster:    def __init__(self):        self.ip_address = "0.0.0.0"        self.active = True        self.broadCaster_port_number = None        self.listener_port_number = None        self.set_port()        self.socket = None        self.set_socket()        self.broadCaster_ip = None    def set_port(self):        # self.broadCaster_port_number = random.randint(1024, 10000)        self.broadCaster_port_number = 2000        self.listener_port_number = 2500    def set_socket(self):        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)        self.socket.settimeout(1)        try:            self.socket.bind((self.ip_address, self.broadCaster_port_number))        except socket.error:            print("socket_error_exception_caught")            return -1        return 0    def send_hello(self):        for i in range(10):            message = "Hello"            self.socket.sendto(message.encode(), ('<broadcast>', self.listener_port_number))            print("message sent !")    def receive_and_ack(self):        try:            data, address = self.socket.recvfrom(1024)            print("received_Data", data, "host_ip", address)            message = "ack"            self.socket.sendto(message.encode(), address)        except socket.timeout:            print("socket timeout caught")            return -1        return 0    def run(self):        flag1 = self.set_socket()        if flag1 == -1:            return flag1        else:            self.send_hello()            flag2 = self.receive_and_ack()            if flag2 == -1:                return flag2            else:                # in this situation we received data                self.close_socket()        return 0    def close_socket(self):        self.socket.close()class UdpListener:    def __init__(self):        self.ip_address = "0.0.0.0"        self.active = True        self.broadCaster_port_number = None        self.listener_port_number = None        self.set_port()        self.socket = None        self.set_socket()        self.broadCaster_ip = None    def set_port(self):        self.broadCaster_port_number = 2000        self.listener_port_number = 2500    # self.broadCaster_port_number = random.randint(1024, 10000)    def set_tcp_port_number(self):        self.tcp_port_number = random.randint(1024, 10000)    def set_socket(self):        self.socket = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)        self.socket.settimeout(1.3)        try:            self.socket.bind((self.ip_address, self.listener_port_number))        except socket.error:            print("socket_error_on_listening_and_binding")            return -1        return 0    def send_ip(self):        self.set_tcp_port_number()        message = "my_tcp_port_is_" + str(self.tcp_port_number)        print(self.broadCaster_ip, self.broadCaster_port_number)        for j in range(5):            self.socket.sendto(message.encode(), (self.broadCaster_ip, self.broadCaster_port_number))        print("message sent !")        return 0    def receive_hello(self, state="receive_hello"):        print("looking_for_" + state)        try:            data, address = self.socket.recvfrom(1024)            print("received message : ", data, address)            self.broadCaster_ip = address[0]        except socket.timeout:            print("socket timeout caught")            return -1        return 0    def receive_ack(self, state="receiving_ack"):        print("looking_for_" + state)        while True:            try:                data, address = self.socket.recvfrom(1024)                print("received message : ", data, address)                self.broadCaster_ip = address[0]                if data.decode() == 'ack':                    print('ack received')                    break            except socket.timeout:                print("socket timeout caught")                return -1        return 0    def run(self):        flag1 = self.receive_hello()        if flag1 == -1:            pass        elif flag1 == 0:            self.send_ip()            self.receive_ack(state="receive_ack")        else:            raise ValueError        self.socket.close()class ChatTester:    def __init__(self):        while True:            udpBroadCaster = UdpBroadCaster()            value = udpBroadCaster.run()            del udpBroadCaster            if value != 0:                udpListener = UdpListener()                udpListener.run()                del udpListenerchatTester = ChatServer()